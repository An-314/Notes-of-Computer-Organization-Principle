#/* $begin ncopy-ys */
##################################################################
# ncopy.ys - Copy a src block of len words to dst.
# Return the number of positive words (>0) contained in src.
#
# Include your name and ID here.
#
# Describe how and why you modified the baseline code.
#
##################################################################
# Do not modify this portion
# Function prologue.
# %rdi = src, %rsi = dst, %rdx = len
ncopy:

##################################################################
    # count = 0
    xorq    %rax, %rax

    # if len <= 0: return 0
    andq    %rdx, %rdx
    jle     Done

    # constant 1
    irmovq  $1, %r8

    # Pre-decrement len by 8 to set up the 8-way loop.
    # If len < 8, jump to remainder handler (with len stored as len-8).
    iaddq   $-8, %rdx
    jl      RemLess8

Loop8:
    # Load 4 values
    mrmovq  0(%rdi),  %r10
    mrmovq  8(%rdi),  %r11
    mrmovq  16(%rdi), %r12
    mrmovq  24(%rdi), %r13

    # Store/test/count, while loading the next 4 values to keep load/use gaps.
    rmmovq  %r10, 0(%rsi)
    andq    %r10, %r10
    jle     L0
    addq    %r8,  %rax
L0:
    mrmovq  32(%rdi), %r10

    rmmovq  %r11, 8(%rsi)
    andq    %r11, %r11
    jle     L1
    addq    %r8,  %rax
L1:
    mrmovq  40(%rdi), %r11

    rmmovq  %r12, 16(%rsi)
    andq    %r12, %r12
    jle     L2
    addq    %r8,  %rax
L2:
    mrmovq  48(%rdi), %r12

    rmmovq  %r13, 24(%rsi)
    andq    %r13, %r13
    jle     L3
    addq    %r8,  %rax
L3:
    mrmovq  56(%rdi), %r13

    # Store/test/count the last 4 values.
    rmmovq  %r10, 32(%rsi)
    andq    %r10, %r10
    jle     L4
    addq    %r8,  %rax
L4:
    rmmovq  %r11, 40(%rsi)
    andq    %r11, %r11
    jle     L5
    addq    %r8,  %rax
L5:
    rmmovq  %r12, 48(%rsi)
    andq    %r12, %r12
    jle     L6
    addq    %r8,  %rax
L6:
    rmmovq  %r13, 56(%rsi)
    andq    %r13, %r13
    jle     L7
    addq    %r8,  %rax
L7:
    # Advance pointers
    iaddq   $64, %rdi
    iaddq   $64, %rsi

    # len -= 8; if len >= 0, loop again
    iaddq   $-8, %rdx
    jge     Loop8

RemLess8:
    # Restore remaining length (0..7)
    iaddq   $8, %rdx

Rem4Check:
    # if rem < 4 -> Rem2Check
    rrmovq  %rdx, %r14
    iaddq   $-4, %r14
    jl      Rem2Check

    # Load 4
    mrmovq  0(%rdi),  %r10
    mrmovq  8(%rdi),  %r11
    mrmovq  16(%rdi), %r12
    mrmovq  24(%rdi), %r13

    # Store/test/count 4
    rmmovq  %r10, 0(%rsi)
    andq    %r10, %r10
    jle     R40
    addq    %r8,  %rax
R40:
    rmmovq  %r11, 8(%rsi)
    andq    %r11, %r11
    jle     R41
    addq    %r8,  %rax
R41:
    rmmovq  %r12, 16(%rsi)
    andq    %r12, %r12
    jle     R42
    addq    %r8,  %rax
R42:
    rmmovq  %r13, 24(%rsi)
    andq    %r13, %r13
    jle     R43
    addq    %r8,  %rax
R43:
    iaddq   $32, %rdi
    iaddq   $32, %rsi
    iaddq   $-4, %rdx

Rem2Check:
    # if rem < 2 -> Rem1Check
    rrmovq  %rdx, %r14
    iaddq   $-2, %r14
    jl      Rem1Check

    # Load 2
    mrmovq  0(%rdi), %r10
    mrmovq  8(%rdi), %r11

    # Store/test/count 2
    rmmovq  %r10, 0(%rsi)
    andq    %r10, %r10
    jle     R20
    addq    %r8,  %rax
R20:
    rmmovq  %r11, 8(%rsi)
    andq    %r11, %r11
    jle     R21
    addq    %r8,  %rax
R21:
    iaddq   $16, %rdi
    iaddq   $16, %rsi
    iaddq   $-2, %rdx

Rem1Check:
    andq    %rdx, %rdx
    jle     Done

    # Load 1, insert an independent instruction to avoid load/use stall
    mrmovq  0(%rdi), %r10
    iaddq   $-1, %rdx

    rmmovq  %r10, 0(%rsi)
    andq    %r10, %r10
    jle     Done
    addq    %r8,  %rax
##################################################################
# Do not modify the following section of code
# Function epilogue.
Done:
	ret
##################################################################
# Keep the following label at the end of your function
End:
#/* $end ncopy-ys */
