#import "@preview/scripst:1.1.1": *

#show: scripst.with(
  title: [计算机组成原理],
  info: [第二次作业],
  author: "Anzrew",
  time: "2025/9/23",
)

#problem(subname: [2.83])[
  一些数字的二进制表示是由形如`0. y y y y y y ...`的无穷串组成的，其中`y`是一个$k$位的序列。例如，`1/3`的二进制表示是`0.01010101 ... (y = 01)`，而`1/5`的二进制表示是`0.001100110011 ... (y=0011)` 。
  + 设$Y="B2U"_k (y)$，也就是说，这个数具有二进制表示$y$。给出一个由$Y$和$k$组成的公式表示这个无穷串的值。
    - 提示：请考虑将二进制小数点右移$k$位的结果。
  + 对于下列的$y$值，串的数值是多少?
    - $101$
    - $0110$
    - $010011$
]

#solution[
  + 设$Y="B2U"_k (y)$，也就是说，这个数具有二进制表示$Y$。
    $
      2^k x = #raw("y.yyyyy...") = x + Y
    $
    从而
    $
      x = Y/(2^k - 1)
    $
  + 代入计算
    - $
        y = 101(k=3), Y=5\
        x = 5/(2^3 - 1) = 5/7
      $
    - $
        y = 0110(k=4), Y=6\
        x = 6/(2^4 - 1) = 6/15
      $
    - $
        y = 010011(k=6), Y=19\
        x = 19/(2^6 - 1) = 19/63
      $
]


#problem(subname: [2.86])[
  与Intel兼容的处理器也支持“扩展精度”浮点形式，这种格式具有80位字长，被分成1个符号位、k=15个阶码位、1个单独的整数位和n=63个小数位。整数位是IEEE浮点表示中隐含位的显式副本。也就是说，对于规格化的值它等于1，对于非规格化的值它等于0。填写下表，给出用这种格式表示的一些“有趣的”数字的近似值。

  #three-line-table[
    | 描述 | 拓展精度 | < |
    | :---: | :---: | :---: |
    | \  | 值 | 十进制 |
    | 最小的非规格化数 | \ | \ |
    | 最小的正规格化数 | \ | \ |
    | 最大的规格化数 | \ | \ |
  ]

  将数据类型声明为long double，就可以把这种格式用于为与Intel兼容的机器编译C程序。但是，它会强制编译器以传统的8087浮点指令为基础生成代码。由此产生的程序很可能会比数据类型为float或double的情况慢上许多。
]

#solution[

  格式：
  - $s=1$ 符号位
  - $k=15$ 指数位（Bias = 16383）
  - 显式整数位（规格化时=1，非规格化时=0），$n=63$ 小数位
  #three-line-table[
    |    描述    |                        拓展精度                       |                       <                       |
    | :------: | :-----------------------------------------------: | :-------------------------------------------: |
    |     \    |                         值                         |                      十进制                      |
    | 最小的非规格化数 | s=0,exp=0,整数位=0,frac=000...01 | $2^(1-16483) times 2^(-63)=2^(-16445)$ |
    | 最小的正规格化数 | s=0,exp=1,整数位=1,frac=000...00 | $2^(1-16483) times 1 = 2^(-16382)$ |
    | 最大的规格化数 | s=0,exp=32766,整数位=1,frac=111...11 | $2^(32766-16483) times (2-2^(-63)) = 2^16384 - 2^1620$ |
  ]
]

#problem(subname: [2.88])[
  考虑下面两个基于IEEE浮点格式的9位浮点表示。
  + 格式A
    - 有一个符号位。
    - 有k=5个阶码位。阶码偏置量是15。
    - 有n=3个小数位。
  + 格式B
    - 有一个符号位。
    - 有k=4个阶码位。阶码偏置量是7。
    - 有n=4个小数位。
  下面给出了一些格式A表示的位模式，你的任务是把它们转换成最接近的格式B表示的值。如果需要舍入，你要向$+∞$舍入。另外，给出用格式A和格式B表示的位模式对应的值。要么是整数(例如$17$)，要么是小数(例如$17/64$或$17/2^6$)。
  #three-line-table[
    | 格式 A | < | 格式 B | < |
    | :---: | :---: | :---: | :---: |
    | 位 | 值 | 位 | 值 |
    | 1 01110 001 | $-9/16$ | 1 0110 0010 | $-9/16$ |
    | 0 10110 101 | \ | \ | \ |
    | 1 00111 110 | \ | \ | \ |
    | 0 00000 101 | \ | \ | \ |
    | 1 11011 000 | \ | \ | \ |
    | 0 11000 100 | \ | \ | \ |
  ]
]

#solution[
  利用舍入规则，对每一位进行舍入
  #three-line-table[
    | 格式 | 位 | s | exp | E = exp - bias($15$/$7$) | frac | M $<-$ frac | 值 |
    | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
    | A | 1 01110 001 | 1 | 01110 | $14-15=-1$ | 001 | $1+2^(-3)$ | $- 2^(-1) times 9/8 = -9/16$ |
    | B | 1 0110 0010 | 1 | 0110 | $6-7=-1$ | 0010 | $1+2^(-3)$ | $- 2^(-1) times 9/8 = -9/16$ |
    | A | 0 10110 101 | 0 | 10110 | $22-15=7$ | 101 | $1+5/8$ | $2^7 times 13/8 = 208$ |
    | B | 0 1110 1010 | 0 | 1110 | $14-7=7$ | 1010 | $1+5/8$ | $2^7 times 13/8 = 208$ |
    | A | 1 00111 110 | 1 | 00111 | $7-15=-8$ | 110 | $1+3/4$ | $- 2^(-8) times 7/4 = -7/2^10$ |
    | B | 1 0000 101 | 1 | 0000 | $1-7=-6$ | 0111 | $7/16$ | $- 2^(-6) times 7/16 = -7/2^10$ |
    | A | 0 00000 101 | 0 | 00000 | $1-15=-14$ | 101 | $5/8$ | $2^(-14) times 5/8 = 5/2^17$ |
    | B | 0 0000 0001 | 0 | 0000 | $1-7=-6$ | 0001 | $1/16$ | $- 2^(-6) times 1/16 = -1/2^10$ |
    | A | 1 11011 000 | 1 | 11011 | $27-15=12$ | 000 | $1+0$ | $- 2^12 times 1 = -2^12$ |
    | B | 1 1110 1111 | 1 | 1110 | $14-7=7$ | 1111 | $1+15/16$ | $- 2^7 times 31/16 = -31 times 2^3$ |
    | A | 0 11000 100 | 0 | 11000 | $24-15=9$ | 100 | $1+1/2$ | $- 2^9 times 3/2 = 3 times 2^8$ |
    | B | 0 1111 0000 | 0 | 1111 | $oo$ | 0000 | - | $oo$ |
  ]

]
