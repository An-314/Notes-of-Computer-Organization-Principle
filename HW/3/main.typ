#import "@preview/scripst:1.1.1": *

#show: scripst.with(
  title: [计算机组成原理],
  info: [第三次作业],
  author: "Anzrew",
  time: "2025/11/7",
)

#problem(subname: [3.1])[
  Assume the following values are stored at the indicated memory addresses and registers:
  #align(center)[#three-line-table[
    | address | value | register | value |
    |---------|-------|----------|-------|
    |`0x100`    |`0xFF`   |`%rax`      |`0x100`  |
    |`0x104`    |`0xAB`   |`%rcx`      |`0x10`  |
    |`0x108`    |`0x13`   |`%rdx`      |`0x3`  |
    |`0x10C`    |`0x11`   |    \       | \     |
  ]]
  Fill in the following table showing the values for the indicated operands:
  #align(center)[#three-line-table[
    | Operand        | Value |
    |----------------|-------|
    | `%rax` | \ |
    | `0x104` | \ |
    | `$0x108` | \ |
    | `(%rax)` | \ |
    | `4(%rax)` | \ |
    | `9(%rax,%rdx)` | \ |
    | `260(%rcx,%rdx)` | \ |
    | `0xFC(,%rcx,4)` | \ |
    | `(%rax,%rdx,4)` | \ |
  ]]
]

#problem(subname: [3.15])[
  In the following excerpts from a disassembled binary, some of the information has been replaced by X's. Answer the following questions about these instructions.
  + What is the target of the `je` instruction below?(You do not need to know anything about the `callq` instruction here.)
    ```asm
    4003fa: 74 02           je     XXXXXX
    4003fc: ff d0           callq  *%rax
    ```
  + What is the target of the `je` instruction below?
    ```asm
    40042f: 74 f4           je     XXXXXX
    400431: 5d              pop    %rbp
    ```
  + What is the address of the `ja` and `pop` instructions?
    ```asm
    XXXXXX: 77 02           ja     400547
    XXXXXX: 5d              pop    %rbp
    ```
  + In the code that follows, the jump target is encoded in PC-relative form as a 4-byte two's-complement number. The bytes are listed from least significant to most, reflecting the little-endian byte ordering of x86-64. What is the address of the jump target?
    ```asm
    4005e8: e9 73 ff ff ff  jmpq   XXXXXX
    4005ed: 90              nop
    ```
]

#problem(subname: [3.35])[
  For a C function having the general structure
  ```c
  long rfun(unsigned long x){
    if(________)
      return ________;
    unsigned long nx=________;
    long rv=rfun(nx);
    return ________;
  }
  ```
  gcc generates the following assembly code:
  ```asm
  # long rfun(unsigned long x)
  # x in %rdi
  rfun:
    pushq  %rbx
    movq   %rdi, %rbx
    movl   $0, %eax
    testq  %rdi, %rdi
    je     .L2
    shrq   $2, %rdi
    call   rfun
    addq   %rbx, %rax
  .L2:
    popq   %rbx
    ret
  ```
  + What value does rfun store in the callee-save register `%rbx`?
  + Fill in the missing expressions in the C code shown above.
]

#problem(subname: [3.60])[
  Consider the following assembly code:
  ```asm
  # long loop(long x, int n)
  # x in %rdi, n in %esi
  loop:
    movl    %esi, %ecx
    movl    $1, %edx
    movl    $0, %eax
    jmp     .L2
  .L3:
    movq    %rdi, %r8
    andq    %rdx, %r8
    orq     %r8, %rax
    salq    %cl, %rdx
  .L2:
    testq   %rdx, %rdx
    jne     .L3
    rep; ret
  ```
  The preceding code was generated by compiling C code that had the following overall form:
  ```c
  long loop(long x, int n)
  {
    long result = ________;
    long mask;
    for (mask = ________; mask ________; mask = ________) {
      result |= ________;
    }
    return result;
  }
  ```
  Your task is to fill in the missing parts of the C code to get a program equivalent to the generated assembly code. Recall that the result of the function is returned in register `%rax`. You will find it helpful to examine the assembly code before, during, and after the loop to form a consistent mapping between the registers and the program variables.
  + Which registers hold program values `x`, `n`, `result`, and `mask`?
  + What are the initial values of `result` and `mask`?
  + What is the test condition for `mask`?
  + How does `mask` get updated?
  + How does `result` get updated?
  + Fill in all the missing parts of the C code
]

#problem(subname: [3.61])[
  In Section 3.6.6, we examined the following code as a candidate for the use of conditional data transfer:
  ```c
  long cread(long *xp) {
    return (xp ? *xp : 0);
  }
  ```
  #newpara()
  We showed a trial implementation using a conditional move instruction but argued that it was not valid, since it could attempt to read from a null address.

  Write a C function `cread_alt` that has the same behavior as cread, except that it can be compiled to use conditional data transfer. When compiled, the generated code should use a conditional move instruction rather than one of the jump instructions.
]
